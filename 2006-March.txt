From crazycoder at berlios.de  Wed Mar  1 17:47:42 2006
From: crazycoder at berlios.de (crazycoder at BerliOS)
Date: Wed, 1 Mar 2006 17:47:42 +0100
Subject: [Jircii-svn] r78 - in rero: resources/resource resources/toplevel src/rero/client/functions src/rero/ircfw
Message-ID: <200603011647.k21GlgqY011243@sheep.berlios.de>

Author: crazycoder
Date: 2006-03-01 17:47:40 +0100 (Wed, 01 Mar 2006)
New Revision: 78

Modified:
   rero/resources/resource/default.irc
   rero/resources/toplevel/whatsnew.txt
   rero/src/rero/client/functions/ChannelOperators.java
   rero/src/rero/ircfw/UserMode.java
Log:
- Fixed modes in nicklist and status bar (all possible channel modes
  should be correctly supported now, including &, ~, .) (Serge)
- Fixed &getModeFor returning 2 characters in some cases. According
  to docs it should always return the highest channel mode user has
  as a single character (Serge)
- Added @ &getModeChars function, returns channel mode chars supported
  by the server (@,%,+,&,~,.) (Serge)

Modified: rero/resources/resource/default.irc
===================================================================
--- rero/resources/resource/default.irc	2006-02-23 15:28:59 UTC (rev 77)
+++ rero/resources/resource/default.irc	2006-03-01 16:47:40 UTC (rev 78)
@@ -88,25 +88,26 @@
    return formatNick($nick, $channel, $nick);
 }
 
-sub formatNick
-{
-   if ($1 isop $2) 
-   {
-      return "\C26@\C29 $+ $3";
-   }
-   else if ($1 ishalfop $2)
-   {
-      return "\C28%\C29 $+ $3";
-   }
-   else if ($1 isvoice $2)
-   {
-      return "\C27+\C29 $+ $3";
-   }
-   else if ($1 hasmode $2)
-   {
-      return "\C26\B" . getModeFor($1, $2) . "\B\C29 $+ $3";
-   }
-   return "\C29 $+ $3";
+sub formatNick {
+  if (($1 !hasmode $2)) {
+    return "\C29 $+ $3";
+  }
+
+  $uchar = getModeFor($1, $2);
+
+  if($uchar eq '@') {
+    return "\C26@\C29 $+ $3";
+  }
+
+  if($uchar eq '%') {
+    return "\C28%\C29 $+ $3";
+  }
+
+  if($uchar eq '+') {
+    return "\C27+\C29 $+ $3";
+  }
+
+  return "\C26\B $+ $uchar $+ \B\C29 $+ $3";
 }
 
 set CHANNEL_CREATED!
@@ -499,22 +500,11 @@
 
 set SBAR_LEFT 
 {
-  if ($me isop $query) 
-  {
-     $ime = "\B@\B $+ $me";
+  if (($me hasmode $query)) {
+    $ime = "\B" . getModeFor($me, $query) . "\B $+ $me";
+  } else {
+    $ime = "$me";
   }
-  else if ($me isvoice $query) 
-  {
-     $ime = "\B+\B $+ $me";
-  }
-  else if ($me ishalfop $query)
-  {
-     $ime = "\B%\B $+ $me";
-  }
-  else
-  {
-     $ime = "$me";
-  }
 
   if ($me ison $query)
   {

Modified: rero/resources/toplevel/whatsnew.txt
===================================================================
--- rero/resources/toplevel/whatsnew.txt	2006-02-23 15:28:59 UTC (rev 77)
+++ rero/resources/toplevel/whatsnew.txt	2006-03-01 16:47:40 UTC (rev 78)
@@ -30,8 +30,14 @@
 - Implemented automatic word wrapping of long messages if packet doesn't
   fit 512 bytes RFC length. For details check this link:
   http://www.resultspk.net/hackirc/irchks-chp-13-sect-3.html (Serge)
+- Fixed modes in nicklist and status bar (all possible channel modes
+  should be correctly supported now, including &, ~, .) (Serge)
+- Fixed &getModeFor returning 2 characters in some cases. According
+  to docs it should always return the highest channel mode user has
+  as a single character (Serge)
+- Added @ &getModeChars function, returns channel mode chars supported
+  by the server (@,%,+,&,~,.) (Serge)
 
-
 Beta    39 release 07.30.05
 ====
 - The find feature is now case insensitive (oracel)

Modified: rero/src/rero/client/functions/ChannelOperators.java
===================================================================
--- rero/src/rero/client/functions/ChannelOperators.java	2006-02-23 15:28:59 UTC (rev 77)
+++ rero/src/rero/client/functions/ChannelOperators.java	2006-03-01 16:47:40 UTC (rev 78)
@@ -1,205 +1,189 @@
 package rero.client.functions;
 
-import sleep.engine.*;
-import sleep.runtime.*;
-import sleep.interfaces.*;
-
-import rero.client.*;
-import rero.ircfw.data.*;
-import rero.ircfw.*;
-
+import rero.client.Feature;
+import rero.ircfw.Channel;
+import rero.ircfw.InternalDataList;
 import sleep.bridges.BridgeUtilities;
+import sleep.interfaces.Function;
+import sleep.interfaces.Loadable;
+import sleep.interfaces.Predicate;
+import sleep.runtime.Scalar;
+import sleep.runtime.ScriptInstance;
+import sleep.runtime.SleepUtils;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Stack;
 
-public class ChannelOperators extends Feature implements Predicate, Function, Loadable
-{
-   protected InternalDataList data;
- 
-   public void init()
-   {
-      getCapabilities().getScriptCore().addBridge(this);
-      
-      data = (InternalDataList)getCapabilities().getDataStructure("clientInformation");
-   }
+public class ChannelOperators extends Feature implements Predicate, Function, Loadable {
+  protected InternalDataList data;
 
-   public boolean scriptLoaded(ScriptInstance script)
-   {
-      String[] contents = new String[] { 
-          "ison",      /** predicates */
-          "isop",
-          "ishalfop",
-          "isvoice",
-          "isnormal",
-          "ismode",
-          "hasmode",
-          "&getUsers",  /** functions that return an array value */
-          "&getOps",
-          "&getHalfOps",
-          "&getVoiced",
-          "&getNormal",
-          "&getTopic",  /** functions that return a normal scalar value */
-          "&getKey",
-          "&getMode",
-          "&getLimit",
-          "&getModeFor"
-      };
+  public void init() {
+    getCapabilities().getScriptCore().addBridge(this);
 
-      for (int x = 0; x < contents.length; x++)
-      {
-         script.getScriptEnvironment().getEnvironment().put(contents[x], this);
-      }       
+    data = (InternalDataList) getCapabilities().getDataStructure("clientInformation");
+  }
 
-      return true;
-   }
+  public boolean scriptLoaded(ScriptInstance script) {
+    String[] contents = new String[]{
+      "ison",      /** predicates */
+      "isop",
+      "ishalfop",
+      "isvoice",
+      "isnormal",
+      "ismode",
+      "hasmode",
+      "&getUsers",  /** functions that return an array value */
+      "&getOps",
+      "&getHalfOps",
+      "&getVoiced",
+      "&getNormal",
+      "&getTopic",  /** functions that return a normal scalar value */
+      "&getKey",
+      "&getMode",
+      "&getLimit",
+      "&getModeFor",
+      "&getModeChars"
+    };
 
-   public boolean scriptUnloaded(ScriptInstance script)
-   {
-      return true;
-   }
+    for (int x = 0; x < contents.length; x++) {
+      script.getScriptEnvironment().getEnvironment().put(contents[x], this);
+    }
 
-   public Scalar evaluate(String function, ScriptInstance script, Stack locals)
-   {
-      if (function.equals("&getModeFor"))
-      {
-          String  _nick    = BridgeUtilities.getString(locals, "");
-          String  _channel = BridgeUtilities.getString(locals, "");
-          Channel channel  = data.getChannel(_channel);
- 
-          if (data.getUser(_nick) == null)
-              return SleepUtils.getEmptyScalar();
+    return true;
+  }
 
-          return SleepUtils.getScalar(data.getPrefixInfo().toString(data.getUser(_nick).getModeFor(channel)));
-      }
+  public boolean scriptUnloaded(ScriptInstance script) {
+    return true;
+  }
 
-      if (locals.size() != 1)
-      {
-         return SleepUtils.getEmptyScalar();
+  public Scalar evaluate(String function, ScriptInstance script, Stack locals) {
+    if (function.equals("&getModeChars")) {
+      String modes = data.getPrefixInfo().getModes();
+      char[] chars = modes.toCharArray();
+      ArrayList ch = new ArrayList(chars.length);
+      for (int i = 0; i < chars.length; i++) {
+        char mchar = chars[i];
+        ch.add(String.valueOf(mchar));
       }
+      return SleepUtils.getArrayWrapper(ch);
+    }
 
-      String  _channel = ((Scalar)locals.pop()).getValue().toString();
+    if (function.equals("&getModeFor")) {
+      String _nick = BridgeUtilities.getString(locals, "");
+      String _channel = BridgeUtilities.getString(locals, "");
       Channel channel = data.getChannel(_channel);
-  
-      if (channel == null)
-      {
-         return null;
-      }
 
-      if (function.equals("&getTopic"))
-      {
-         return SleepUtils.getScalar(channel.getTopic());
-      }
+      if (data.getUser(_nick) == null)
+        return SleepUtils.getEmptyScalar();
 
-      if (function.equals("&getMode"))
-      {
-         return SleepUtils.getScalar(channel.getMode().toString());
-      }
+      return SleepUtils.getScalar(data.getPrefixInfo().toString(data.getUser(_nick).getModeFor(channel)));
+    }
 
-      if (function.equals("&getKey"))
-      {
-         return SleepUtils.getScalar(channel.getKey());
-      }
+    if (locals.size() != 1) {
+      return SleepUtils.getEmptyScalar();
+    }
 
-      if (function.equals("&getLimit"))
-      {
-         return SleepUtils.getScalar(channel.getLimit());
-      }
+    String _channel = ((Scalar) locals.pop()).getValue().toString();
+    Channel channel = data.getChannel(_channel);
 
-      Stack rv = new Stack();
-      Iterator i = null;
+    if (channel == null) {
+      return null;
+    }
 
-      if (function.equals("&getUsers"))
-      {
-         return SleepUtils.getArrayWrapper(channel.getAllUsers());
-      }
+    if (function.equals("&getTopic")) {
+      return SleepUtils.getScalar(channel.getTopic());
+    }
 
-      if (function.equals("&getOps"))
-      {
-         return SleepUtils.getArrayWrapper(data.getUsersWithMode(_channel, 'o'));
-      }
+    if (function.equals("&getMode")) {
+      return SleepUtils.getScalar(channel.getMode().toString());
+    }
 
-      if (function.equals("&getHalfOps"))
-      {
-         return SleepUtils.getArrayWrapper(data.getUsersWithMode(_channel, 'h'));
-      }
+    if (function.equals("&getKey")) {
+      return SleepUtils.getScalar(channel.getKey());
+    }
 
-      if (function.equals("&getVoiced"))
-      {
-         return SleepUtils.getArrayWrapper(data.getUsersWithMode(_channel, 'v'));
-      }
+    if (function.equals("&getLimit")) {
+      return SleepUtils.getScalar(channel.getLimit());
+    }
 
-      if (function.equals("&getNormal"))
-      {
-         return SleepUtils.getArrayWrapper(data.getUsersWithMode(_channel, ' '));
-      }
+    Stack rv = new Stack();
+    Iterator i = null;
 
-      return null;
-   }
+    if (function.equals("&getUsers")) {
+      return SleepUtils.getArrayWrapper(channel.getAllUsers());
+    }
 
-   public boolean decide(String predicate, ScriptInstance script, Stack terms)
-   {
-      if (terms.size() != 2)
-      {
-         return false;
-      }
+    if (function.equals("&getOps")) {
+      return SleepUtils.getArrayWrapper(data.getUsersWithMode(_channel, 'o'));
+    }
 
-      String channel = ((Scalar)terms.pop()).getValue().toString();  
-      String nick    = ((Scalar)terms.pop()).getValue().toString();
- 
-      if (data.getChannel(channel) == null)
-      {
-         return false;
-      }
+    if (function.equals("&getHalfOps")) {
+      return SleepUtils.getArrayWrapper(data.getUsersWithMode(_channel, 'h'));
+    }
 
-      if (predicate.equals("ismode")) 
-      {
-         for (int x = 0; x < nick.length(); x++)
-         {
-            if (! data.getChannel(channel).getMode().isSet(nick.charAt(x)) )
-            {
-               return false;
-            }
-         }
-         return true;
-      }
+    if (function.equals("&getVoiced")) {
+      return SleepUtils.getArrayWrapper(data.getUsersWithMode(_channel, 'v'));
+    }
 
-      if (!data.isUser(nick))
-      {
-         return false;
-      }
+    if (function.equals("&getNormal")) {
+      return SleepUtils.getArrayWrapper(data.getUsersWithMode(_channel, ' '));
+    }
 
-      if (predicate.equals("ison"))
-      {
-         return data.isOn(data.getUser(nick), data.getChannel(channel));
-      } 
+    return null;
+  }
 
-      int temp = data.getUser(nick).getModeFor(data.getChannel(channel));
-     
-      if (predicate.equals("isop"))
-      {
-         return data.getPrefixInfo().isMode(temp, 'o');
-      }
+  public boolean decide(String predicate, ScriptInstance script, Stack terms) {
+    if (terms.size() != 2) {
+      return false;
+    }
 
-      if (predicate.equals("ishalfop"))
-      {
-         return data.getPrefixInfo().isMode(temp, 'h');
-      }
+    String channel = ((Scalar) terms.pop()).getValue().toString();
+    String nick = ((Scalar) terms.pop()).getValue().toString();
 
-      if (predicate.equals("isvoice"))
-      {
-         return data.getPrefixInfo().isMode(temp, 'v');
-      }
+    if (data.getChannel(channel) == null) {
+      return false;
+    }
 
-      if (predicate.equals("isnormal"))
-      {
-         return temp == 0;
+    if (predicate.equals("ismode")) {
+      for (int x = 0; x < nick.length(); x++) {
+        if (! data.getChannel(channel).getMode().isSet(nick.charAt(x))) {
+          return false;
+        }
       }
+      return true;
+    }
 
-      if (predicate.equals("hasmode"))
-      {
-         return temp != 0;
-      }
-
+    if (!data.isUser(nick)) {
       return false;
-   }
+    }
+
+    if (predicate.equals("ison")) {
+      return data.isOn(data.getUser(nick), data.getChannel(channel));
+    }
+
+    int temp = data.getUser(nick).getModeFor(data.getChannel(channel));
+
+    if (predicate.equals("isop")) {
+      return data.getPrefixInfo().isMode(temp, 'o');
+    }
+
+    if (predicate.equals("ishalfop")) {
+      return data.getPrefixInfo().isMode(temp, 'h');
+    }
+
+    if (predicate.equals("isvoice")) {
+      return data.getPrefixInfo().isMode(temp, 'v');
+    }
+
+    if (predicate.equals("isnormal")) {
+      return temp == 0;
+    }
+
+    if (predicate.equals("hasmode")) {
+      return temp != 0;
+    }
+
+    return false;
+  }
 }

Modified: rero/src/rero/ircfw/UserMode.java
===================================================================
--- rero/src/rero/ircfw/UserMode.java	2006-02-23 15:28:59 UTC (rev 77)
+++ rero/src/rero/ircfw/UserMode.java	2006-03-01 16:47:40 UTC (rev 78)
@@ -1,101 +1,96 @@
 package rero.ircfw;
 
-import java.util.*;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Set;
 
-/** This class is a mode interpreter for each server.  Basically each server can have channel user prefix modes.
-    The state of these modes is stored as an int within each User object (associated in a hashmap with the Channel
-    object as the key).  This class is used to make sense of the integer mode value for a given servers configuration */
-public class UserMode
-{
-   private String modes; // the actual mode characters i.e. ov
-   private String chars; // the actual display characters i.e. @+ 
+/**
+ * This class is a mode interpreter for each server.  Basically each server can have channel user prefix modes. The
+ * state of these modes is stored as an int within each User object (associated in a hashmap with the Channel object as
+ * the key).  This class is used to make sense of the integer mode value for a given servers configuration
+ */
+public class UserMode {
+  private String modes; // the actual mode characters i.e. ov
+  private String chars; // the actual display characters i.e. @+
 
-   public UserMode(String m, String c)
-   {
-      modes = m;
-      chars = c;
-   }
+  public UserMode(String m, String c) {
+    modes = m;
+    chars = c;
+  }
 
-   public Set getUsersWithMode(Channel channel, char mode)
-   {
-      Set copy = new LinkedHashSet();
-      Iterator i = channel.getAllUsers().iterator();
-      while (i.hasNext())
-      {
-         User temp = (User)i.next();
-         int  m    = temp.getModeFor(channel);
- 
-         if (isMode(m, mode))
-         {
-            copy.add(temp);
-         }
+  public Set getUsersWithMode(Channel channel, char mode) {
+    Set copy = new LinkedHashSet();
+    Iterator i = channel.getAllUsers().iterator();
+    while (i.hasNext()) {
+      User temp = (User) i.next();
+      int m = temp.getModeFor(channel);
+
+      if (isMode(m, mode)) {
+        copy.add(temp);
       }
+    }
 
-      return copy;
-   }
+    return copy;
+  }
 
-   public boolean isPrefixMode(char m)
-   {
-      return modes.indexOf(m) > -1;
-   }
+  public boolean isPrefixMode(char m) {
+    return modes.indexOf(m) > -1;
+  }
 
-   public boolean isPrefixChar(char m)
-   {
-       return chars.indexOf(m) > -1;
-   }
+  public boolean isPrefixChar(char m) {
+    return chars.indexOf(m) > -1;
+  }
 
-   public char getDisplayForMode(char mode)
-   {
-      return chars.charAt(modes.indexOf(mode));
-   }
-    
-   public char getModeForDisplay(char display)
-   {
-      return modes.charAt(chars.indexOf(display));
-   }
+  public char getDisplayForMode(char mode) {
+    return chars.charAt(modes.indexOf(mode));
+  }
 
-   public int getValueFor(char mchar)
-   {
-      return 1 << (modes.length() - modes.indexOf(mchar));
-   }
+  public char getModeForDisplay(char display) {
+    return modes.charAt(chars.indexOf(display));
+  }
 
-   public int setMode(int original, char mchar)
-   {
-      int value = getValueFor(mchar);
-      return original | value;
-   }
+  public int getValueFor(char mchar) {
+    return 1 << (modes.length() - modes.indexOf(mchar));
+  }
 
-   public int unsetMode(int original, char mchar)
-   {
-      int value = getValueFor(mchar);
-      return original & ~(value);
-   }
+  public int setMode(int original, char mchar) {
+    int value = getValueFor(mchar);
+    return original | value;
+  }
 
-   public boolean isMode(int original, char mchar)
-   {
-      if (mchar == ' ' && original == 0)
-            return true;
+  public int unsetMode(int original, char mchar) {
+    int value = getValueFor(mchar);
+    return original & ~(value);
+  }
 
-      int value = getValueFor(mchar);
-      return ((original & value) == value);
-   }
+  public boolean isMode(int original, char mchar) {
+    if (mchar == ' ' && original == 0)
+      return true;
 
-   public String toString(int original)
-   {
-      StringBuffer rv = new StringBuffer();
-      for (int x = 0; x < modes.length(); x++)
-      {
-         if (isMode(original, modes.charAt(x)))
-         {
-            rv.append(chars.charAt(x));
-         }
+    int value = getValueFor(mchar);
+    return ((original & value) == value);
+  }
+
+
+  public String getModes() {
+    return modes;
+  }
+
+  public String getChars() {
+    return chars;
+  }
+
+  public String toString(int original) {
+    for (int x = 0; x < modes.length(); x++) {
+      if (isMode(original, modes.charAt(x))) {
+        return String.valueOf(chars.charAt(x));
       }
+    }
+    return "";
+  }
 
-      return rv.toString();
-   }
+  public String toString() {
+    return "[UCM:(" + modes + ")" + chars + "]";
+  }
 
-   public String toString()
-   {
-      return "[UCM:("+modes+")"+chars+"]";
-   }
 }



From crazycoder at berlios.de  Wed Mar  1 17:50:26 2006
From: crazycoder at berlios.de (crazycoder at BerliOS)
Date: Wed, 1 Mar 2006 17:50:26 +0100
Subject: [Jircii-svn] r79 - rero/src/rero/config
Message-ID: <200603011650.k21GoQFV011688@sheep.berlios.de>

Author: crazycoder
Date: 2006-03-01 17:50:25 +0100 (Wed, 01 Mar 2006)
New Revision: 79

Modified:
   rero/src/rero/config/ClientDefaults.java
Log:
bump version

Modified: rero/src/rero/config/ClientDefaults.java
===================================================================
--- rero/src/rero/config/ClientDefaults.java	2006-03-01 16:47:40 UTC (rev 78)
+++ rero/src/rero/config/ClientDefaults.java	2006-03-01 16:50:25 UTC (rev 79)
@@ -78,7 +78,7 @@
 
    public static final boolean update_ial     = true;
 
-   public static final String  version_string = "02.23.06 (alpha)";
+   public static final String  version_string = "03.01.06 (alpha)";
 
    static
    {



From crazycoder at berlios.de  Sat Mar 18 23:01:04 2006
From: crazycoder at berlios.de (crazycoder at BerliOS)
Date: Sat, 18 Mar 2006 23:01:04 +0100
Subject: [Jircii-svn] r80 - in rero: resources/resource resources/toplevel src/rero/client/server src/rero/config src/rero/ircfw src/rero/ircfw/data
Message-ID: <200603182201.k2IM14Z7023705@sheep.berlios.de>

Author: crazycoder
Date: 2006-03-18 23:01:02 +0100 (Sat, 18 Mar 2006)
New Revision: 80

Modified:
   rero/resources/resource/default.irc
   rero/resources/toplevel/whatsnew.txt
   rero/src/rero/client/server/ProcessEvents.java
   rero/src/rero/config/ClientDefaults.java
   rero/src/rero/ircfw/InternalDataList.java
   rero/src/rero/ircfw/data/ModeTracker.java
   rero/src/rero/ircfw/data/MyInformationTracker.java
Log:
- Fixed modes parsing for modes not currently handled by jIRCii internal
  data structures (this caused problems like incorrect modes for users
  in the nicklist)
- Whois codes support (671 - Unreal secure connection, 310 - Unreal
  available for help, 703 - ircd-RU translation scheme)

Modified: rero/resources/resource/default.irc
===================================================================
--- rero/resources/resource/default.irc	2006-03-01 16:50:25 UTC (rev 79)
+++ rero/resources/resource/default.irc	2006-03-18 22:01:02 UTC (rev 80)
@@ -393,9 +393,12 @@
    return formatWhois("Channels", "\c36 $+ $chtemp"); 
 }
 set REPL_320! { return formatWhois("Secure", "\c35\b $+ $1 $+ \b\c33 $2-"); }
+set REPL_671! { return formatWhois("Secure", "\c35\b $+ $1 $+ \b\c33 $2-"); }
 set REPL_338! { return formatWhois("Host", "$2"); }
 set REPL_379! { return formatWhois("Modes", "$5-"); }
 set REPL_378! { return formatWhois("Mask/IP", "$5-"); }
+set REPL_310! { return formatWhois("Help", "\c35\b $+ $1 \b\c33 $+ $2-"); }
+set REPL_703! { return formatWhois("Codepage", "\c35\b $+ $2 \b\c33 $+ $3-"); }
 
 sub formatWhois
 {

Modified: rero/resources/toplevel/whatsnew.txt
===================================================================
--- rero/resources/toplevel/whatsnew.txt	2006-03-01 16:50:25 UTC (rev 79)
+++ rero/resources/toplevel/whatsnew.txt	2006-03-18 22:01:02 UTC (rev 80)
@@ -37,7 +37,13 @@
   as a single character (Serge)
 - Added @ &getModeChars function, returns channel mode chars supported
   by the server (@,%,+,&,~,.) (Serge)
+- Fixed modes parsing for modes not currently handled by jIRCii internal
+  data structures (this caused problems like incorrect modes for users
+  in the nicklist) (Serge)
+- Whois codes support (671 - Unreal secure connection, 310 - Unreal
+  available for help, 703 - ircd-RU translation scheme) (Serge)
 
+
 Beta    39 release 07.30.05
 ====
 - The find feature is now case insensitive (oracel)

Modified: rero/src/rero/client/server/ProcessEvents.java
===================================================================
--- rero/src/rero/client/server/ProcessEvents.java	2006-03-01 16:50:25 UTC (rev 79)
+++ rero/src/rero/client/server/ProcessEvents.java	2006-03-18 22:01:02 UTC (rev 80)
@@ -456,7 +456,7 @@
 
    private static boolean isWhoisNumeric(int x)
    {
-      return ((x >= 311 && x < 321) || x == 338 || x == 369 || x == 301 || x == 302 || x == 307 || x == 308 || x == 330 || x == 401 || x == 406 || x == 378 || x == 379);
+      return ((x >= 311 && x < 321) || x == 338 || x == 369 || x == 301 || x == 302 || x == 307 || x == 308 || x == 330 || x == 401 || x == 406 || x == 378 || x == 379 || x == 310 || x== 671 || x == 703);
    }
 
    private static class AllowAwayReply implements ChatListener

Modified: rero/src/rero/config/ClientDefaults.java
===================================================================
--- rero/src/rero/config/ClientDefaults.java	2006-03-01 16:50:25 UTC (rev 79)
+++ rero/src/rero/config/ClientDefaults.java	2006-03-18 22:01:02 UTC (rev 80)
@@ -78,7 +78,7 @@
 
    public static final boolean update_ial     = true;
 
-   public static final String  version_string = "03.01.06 (alpha)";
+   public static final String  version_string = "03.19.06 (alpha)";
 
    static
    {

Modified: rero/src/rero/ircfw/InternalDataList.java
===================================================================
--- rero/src/rero/ircfw/InternalDataList.java	2006-03-01 16:50:25 UTC (rev 79)
+++ rero/src/rero/ircfw/InternalDataList.java	2006-03-18 22:01:02 UTC (rev 80)
@@ -13,321 +13,329 @@
 
 import java.util.*;
 
-public class InternalDataList
-{
-    protected String myNickname = "<Unknown>";
-    protected HashMap users = new HashMap(); /* key=<string>, value=<User> */
-    protected MyUser myInformation = new MyUser();
-    protected HashMap channels = new HashMap(); /* key=<string> value=<Channel> */
-    protected HashMap sync = new HashMap(); /* key=<string> value=<ChannelDataWatch> */
+public class InternalDataList {
+  protected String myNickname = "<Unknown>";
+  protected HashMap users = new HashMap(); /* key=<string>, value=<User> */
+  protected MyUser myInformation = new MyUser();
+  protected HashMap channels = new HashMap(); /* key=<string> value=<Channel> */
+  protected HashMap sync = new HashMap(); /* key=<string> value=<ChannelDataWatch> */
 
-    protected HashMap wasOn =
-        new HashMap(); /* key=String value=Set hashmap containing nick->channel mappings for all users who quit.  Upon its first access though the value is removed. */
+  protected HashMap wasOn =
+    new HashMap(); /* key=String value=Set hashmap containing nick->channel mappings for all users who quit.  Upon its first access though the value is removed. */
 
-    protected UserMode umode = new UserMode("ohv", "@%+");
+  protected UserMode umode = new UserMode("ohv", "@%+");
 
-    protected HashMap iSupport = new HashMap();
+  protected HashMap iSupport = new HashMap();
+  protected HashMap chanModes = new HashMap(); // key=<string-group name (A,B,C,D)> value = <string with modes>
 
-    public void reset()
-    {
-        myNickname = "<Unknown>";
-        users = new HashMap();
-        myInformation = new MyUser();
-        channels = new HashMap();
-        umode = new UserMode("ohv", "@%+");
-        iSupport = new HashMap();
-    }
+  public void reset() {
+    myNickname = "<Unknown>";
+    users = new HashMap();
+    myInformation = new MyUser();
+    channels = new HashMap();
+    umode = new UserMode("ohv", "@%+");
+    iSupport = new HashMap();
+    chanModes = new HashMap();
+  }
 
-    public Set getChannelsFromPriorLife(String nick)
-    {
-        Set temp = (Set) wasOn.get(nick);
-        wasOn.remove(temp);
-        return temp;
-    }
+  // checks if the mode belongs to one of the CHANMODES group (A, B, C or D)
+  // A - modes that always have a param and operate user lists
+  // B - modes that always have a param and change setting
+  // C - modes that have a param only when set and change setting
+  // D - modes that never have a param and change setting
+  public boolean isChanGroupMode(String group, char mode) {
+    if (!chanModes.containsKey(group)) return false;
+    String modes = ((String) chanModes.get(group));
+    return modes.indexOf(mode) > -1;
+  }
 
-    public HashMap getSupportInfo() { return iSupport; }
+  public void setChanGroupMode(String group, String modes) {
+    chanModes.put(group, modes);
+  }
 
-    public void addSupportInfo(String key, String value) { iSupport.put(key, value); }
+  public Set getChannelsFromPriorLife(String nick) {
+    Set temp = (Set) wasOn.get(nick);
+    wasOn.remove(temp);
+    return temp;
+  }
 
-    public String getMyNick() { return myNickname; }
+  public HashMap getSupportInfo() {
+    return iSupport;
+  }
 
-    public User getMyUser() { return getUser(getMyNick()); }
+  public void addSupportInfo(String key, String value) {
+    iSupport.put(key, value);
+  }
 
-    public UserMode getPrefixInfo() { return umode; }
+  public String getMyNick() {
+    return myNickname;
+  }
 
-    public void setPrefixInfo(String modes, String chars) { umode = new UserMode(modes, chars); }
+  public User getMyUser() {
+    return getUser(getMyNick());
+  }
 
-    public void setMyNick(String n) { myNickname = n; }
+  public UserMode getPrefixInfo() {
+    return umode;
+  }
 
-    public MyUser getMyUserInformation() { return myInformation; }
+  public void setPrefixInfo(String modes, String chars) {
+    umode = new UserMode(modes, chars);
+  }
 
-    public void installChannelWatch(String channel, ChannelDataWatch ch)
-    {
-        sync.put(channel.toUpperCase(), ch);
-    }
+  public void setMyNick(String n) {
+    myNickname = n;
+  }
 
-    public ChannelDataWatch getChannelDataWatch(Channel ch)
-    {
-        return (ChannelDataWatch) sync.get(ch.getName().toUpperCase());
-    }
+  public MyUser getMyUserInformation() {
+    return myInformation;
+  }
 
-    /**
-     * ********************************************************************
-     */
+  public void installChannelWatch(String channel, ChannelDataWatch ch) {
+    sync.put(channel.toUpperCase(), ch);
+  }
 
-    public LinkedList nickCompleteAll(String pnick, String channel)
-    {
-        LinkedList rv = new LinkedList();
+  public ChannelDataWatch getChannelDataWatch(Channel ch) {
+    return (ChannelDataWatch) sync.get(ch.getName().toUpperCase());
+  }
 
-        if (getChannel(channel) != null) {
-            Set users = getChannel(channel).getAllUsers();
+  /**
+   * ********************************************************************
+   */
 
-            Iterator i = users.iterator();
-            while (i.hasNext()) {
-                User temp = (User) i.next();
-                if (temp.getNick().length() >= pnick.length()) {
-                    if (temp.getNick().toLowerCase().substring(0, pnick.length()).equals(pnick.toLowerCase())) {
-                        rv.addFirst(temp.getNick());
-                    } else
-                    if (temp.getNick().toLowerCase().indexOf(pnick.toLowerCase()) > -1 && (!temp.getNick().toLowerCase().equals(getMyNick().toLowerCase())))
-                    {
-                        rv.addLast(temp.getNick());
-                    }
-                }
-            }
-        }
+  public LinkedList nickCompleteAll(String pnick, String channel) {
+    LinkedList rv = new LinkedList();
 
-        rv.addLast(pnick);
+    if (getChannel(channel) != null) {
+      Set users = getChannel(channel).getAllUsers();
 
-        return rv;
+      Iterator i = users.iterator();
+      while (i.hasNext()) {
+        User temp = (User) i.next();
+        if (temp.getNick().length() >= pnick.length()) {
+          if (temp.getNick().toLowerCase().substring(0, pnick.length()).equals(pnick.toLowerCase())) {
+            rv.addFirst(temp.getNick());
+          } else if (temp.getNick().toLowerCase().indexOf(pnick.toLowerCase()) > -1 &&
+            (!temp.getNick().toLowerCase().equals(getMyNick().toLowerCase()))) {
+            rv.addLast(temp.getNick());
+          }
+        }
+      }
     }
 
-    public String nickComplete(String pnick, String channel)
-    {
-        if (getChannel(channel) == null) {
-            return pnick;
-        }
+    rv.addLast(pnick);
 
-        Set users = getChannel(channel).getAllUsers();
+    return rv;
+  }
 
-        if (isUser(pnick) && users.contains(getUser(pnick))) {
-            return pnick;
-        }
+  public String nickComplete(String pnick, String channel) {
+    if (getChannel(channel) == null) {
+      return pnick;
+    }
 
-        String possible = null;
+    Set users = getChannel(channel).getAllUsers();
 
-        Iterator i = users.iterator();
-        while (i.hasNext()) {
-            User temp = (User) i.next();
-            if (temp.getNick().length() >= pnick.length()) {
-                if (temp.getNick().toLowerCase().substring(0, pnick.length()).equals(pnick.toLowerCase())) {
-                    return temp.getNick();
-                }
+    if (isUser(pnick) && users.contains(getUser(pnick))) {
+      return pnick;
+    }
 
-                if (temp.getNick().toLowerCase().indexOf(pnick.toLowerCase()) > -1 && (!temp.getNick().toLowerCase().equals(getMyNick().toLowerCase())))
-                {
-                    possible = temp.getNick();
-                }
-            }
+    String possible = null;
+
+    Iterator i = users.iterator();
+    while (i.hasNext()) {
+      User temp = (User) i.next();
+      if (temp.getNick().length() >= pnick.length()) {
+        if (temp.getNick().toLowerCase().substring(0, pnick.length()).equals(pnick.toLowerCase())) {
+          return temp.getNick();
         }
 
-        if (possible != null) {
-            return possible;
+        if (temp.getNick().toLowerCase().indexOf(pnick.toLowerCase()) > -1 &&
+          (!temp.getNick().toLowerCase().equals(getMyNick().toLowerCase()))) {
+          possible = temp.getNick();
         }
-
-        return pnick;
+      }
     }
 
-    public Collection getAllUsers()
-    {
-        return users.values();
+    if (possible != null) {
+      return possible;
     }
 
-    public String toString()
-    {
-        return "[IDL for " + myNickname + " - users: " + users.size() + ", channels:  " + channels.size() + "]";
-    }
+    return pnick;
+  }
 
-    public InternalDataList()
-    {
-        /* probably don't need to do anything */
-    }
+  public Collection getAllUsers() {
+    return users.values();
+  }
 
-    public boolean isUser(String nickname)
-    {
-        return (users.get(nickname) != null);
-    }
+  public String toString() {
+    return "[IDL for " + myNickname + " - users: " + users.size() + ", channels:  " + channels.size() + "]";
+  }
 
-    public User getUser(String nickname)
-    {
-        if (users.get(nickname) == null) {
-            users.put(nickname, new User(nickname));
-        }
-        return (User) users.get(nickname);
-    }
+  public InternalDataList() {
+    /* probably don't need to do anything */
+  }
 
-    public Set getUsersWithMode(String channel, char mode)
-    {
-        return umode.getUsersWithMode(getChannel(channel), mode);
+  public boolean isUser(String nickname) {
+    return (users.get(nickname) != null);
+  }
+
+  public User getUser(String nickname) {
+    if (users.get(nickname) == null) {
+      users.put(nickname, new User(nickname));
     }
+    return (User) users.get(nickname);
+  }
 
-    public void QuitNick(String nickname)
-    {
-        Channel temp;
+  public Set getUsersWithMode(String channel, char mode) {
+    return umode.getUsersWithMode(getChannel(channel), mode);
+  }
 
-        Set oldchannels = new HashSet();
+  public void QuitNick(String nickname) {
+    Channel temp;
 
-        Iterator iter = (new LinkedList(getUser(nickname).getChannels())).iterator();
-        while (iter.hasNext()) {
-            temp = (Channel) iter.next();
-            RemoveUser(getUser(nickname), temp);
-            oldchannels.add(temp.getName());
-        }
+    Set oldchannels = new HashSet();
 
-        wasOn.put(nickname, oldchannels);
-
-        users.remove(nickname);
+    Iterator iter = (new LinkedList(getUser(nickname).getChannels())).iterator();
+    while (iter.hasNext()) {
+      temp = (Channel) iter.next();
+      RemoveUser(getUser(nickname), temp);
+      oldchannels.add(temp.getName());
     }
 
-    public void PartNick(String nickname, Channel channel)
-    {
-        if (getMyNick().equals(nickname)) {
-            Iterator iter = channel.getAllUsers().iterator();
-            while (iter.hasNext()) {
-                User temp = (User) iter.next();
-                temp.getChannelData().remove(channel);
+    wasOn.put(nickname, oldchannels);
 
-                if (temp.getChannelData().size() == 0) {
-                    users.remove(temp); // remove users who are no longer visible
-                }
-            }
+    users.remove(nickname);
+  }
 
-            channel.getAllUsers().clear();
-            channels.remove(channel.getName().toUpperCase());
+  public void PartNick(String nickname, Channel channel) {
+    if (getMyNick().equals(nickname)) {
+      Iterator iter = channel.getAllUsers().iterator();
+      while (iter.hasNext()) {
+        User temp = (User) iter.next();
+        temp.getChannelData().remove(channel);
+
+        if (temp.getChannelData().size() == 0) {
+          users.remove(temp); // remove users who are no longer visible
         }
+      }
 
-        RemoveUser(getUser(nickname), channel);
+      channel.getAllUsers().clear();
+      channels.remove(channel.getName().toUpperCase());
     }
 
-    public void JoinNick(String nickname, String channel)
-    {
-        if (getMyNick().equals(nickname)) {
-            createChannel(channel);
-        }
+    RemoveUser(getUser(nickname), channel);
+  }
 
-        getUser(nickname).getChannelData().put(getChannel(channel), new Integer(0));
-        getChannel(channel).getAllUsers().add(getUser(nickname));
+  public void JoinNick(String nickname, String channel) {
+    if (getMyNick().equals(nickname)) {
+      createChannel(channel);
+    }
 
-        if (getChannelDataWatch(getChannel(channel)) != null) {
-            getChannelDataWatch(getChannel(channel)).userAdded(getUser(nickname));
-        }
+    getUser(nickname).getChannelData().put(getChannel(channel), new Integer(0));
+    getChannel(channel).getAllUsers().add(getUser(nickname));
+
+    if (getChannelDataWatch(getChannel(channel)) != null) {
+      getChannelDataWatch(getChannel(channel)).userAdded(getUser(nickname));
     }
+  }
 
-    public void ChangeNick(String oldnick, String newnick)
-    {
-        User temp = getUser(oldnick);
+  public void ChangeNick(String oldnick, String newnick) {
+    User temp = getUser(oldnick);
 
-        // remove the user before the nick is changed in the data structure
-        Channel channel;
+    // remove the user before the nick is changed in the data structure
+    Channel channel;
 
-        Iterator iter = temp.getChannels().iterator();
-        while (iter.hasNext()) {
-            channel = (Channel) iter.next();
-            channel.getAllUsers().remove(temp);
-        }
+    Iterator iter = temp.getChannels().iterator();
+    while (iter.hasNext()) {
+      channel = (Channel) iter.next();
+      channel.getAllUsers().remove(temp);
+    }
 
-        // change the nick in the data structure
-        users.remove(oldnick);
+    // change the nick in the data structure
+    users.remove(oldnick);
 
-        temp.setNick(newnick);
+    temp.setNick(newnick);
 
-        users.put(newnick, temp);
+    users.put(newnick, temp);
 
-        // re add the user to the channel data structure
-        iter = temp.getChannels().iterator();
-        while (iter.hasNext()) {
-            channel = (Channel) iter.next();
-            channel.getAllUsers().add(temp);
+    // re add the user to the channel data structure
+    iter = temp.getChannels().iterator();
+    while (iter.hasNext()) {
+      channel = (Channel) iter.next();
+      channel.getAllUsers().add(temp);
 
-            if (getChannelDataWatch(channel) != null) {
-                getChannelDataWatch(channel).userChanged();
-            }
-        }
-
-        // change my nickname (if applicable)
-        if (oldnick.equals(getMyNick())) {
-            setMyNick(newnick);
-        }
+      if (getChannelDataWatch(channel) != null) {
+        getChannelDataWatch(channel).userChanged();
+      }
     }
 
-    public boolean isOn(User user, Channel channel)
-    {
-        return user != null && user.getChannels().contains(channel);
+    // change my nickname (if applicable)
+    if (oldnick.equals(getMyNick())) {
+      setMyNick(newnick);
     }
+  }
 
-    public void AddUser(String nickname, Channel channel)
-    {
-        int modes = 0;
+  public boolean isOn(User user, Channel channel) {
+    return user != null && user.getChannels().contains(channel);
+  }
 
-        while (umode.isPrefixChar(nickname.charAt(0))) {
-            modes = umode.setMode(modes, umode.getModeForDisplay(nickname.charAt(0)));
-            nickname = nickname.substring(1, nickname.length());
-        }
+  public void AddUser(String nickname, Channel channel) {
+    int modes = 0;
 
-        User user = getUser(nickname);
-
-        // @Serge: when user joins empty channel and obtains +o automatically, he's already present on this channel,
-        // (user.getChannelData().containsKey(channel) returns true on some networks), but without +o,
-        // so we need to update user's mode.
-        // Fix for: http://jirc.hick.org/cgi-bin/bitch.cgi/view.html?7013225
-        if (user.getChannelData().containsKey(channel)) {
-            // only put new mode if it's different
-            if (((Integer) user.getChannelData().get(channel)).intValue() != modes)
-                user.getChannelData().put(channel, new Integer(modes));
-        } else {
-            user.getChannelData().put(channel, new Integer(modes));
-            channel.getAllUsers().add(user);
-        }
+    while (umode.isPrefixChar(nickname.charAt(0))) {
+      modes = umode.setMode(modes, umode.getModeForDisplay(nickname.charAt(0)));
+      nickname = nickname.substring(1, nickname.length());
     }
 
-    public Channel getChannel(String channel)
-    {
-        return (Channel) channels.get(channel.toUpperCase());
+    User user = getUser(nickname);
+
+    // @Serge: when user joins empty channel and obtains +o automatically, he's already present on this channel,
+    // (user.getChannelData().containsKey(channel) returns true on some networks), but without +o,
+    // so we need to update user's mode.
+    // Fix for: http://jirc.hick.org/cgi-bin/bitch.cgi/view.html?7013225
+    if (user.getChannelData().containsKey(channel)) {
+      // only put new mode if it's different
+      if (((Integer) user.getChannelData().get(channel)).intValue() != modes)
+        user.getChannelData().put(channel, new Integer(modes));
+    } else {
+      user.getChannelData().put(channel, new Integer(modes));
+      channel.getAllUsers().add(user);
     }
+  }
 
-    public void createChannel(String channel)
-    {
-        channels.put(channel.toUpperCase(), new Channel(channel));
+  public Channel getChannel(String channel) {
+    return (Channel) channels.get(channel.toUpperCase());
+  }
 
-        if (getChannelDataWatch(getChannel(channel)) != null) {
-            getChannelDataWatch(getChannel(channel)).createChannel(getChannel(channel));
-        }
-    }
+  public void createChannel(String channel) {
+    channels.put(channel.toUpperCase(), new Channel(channel));
 
-    public void synchronizeUserPreChange(User user, Channel channel)
-    {
-        channel.getAllUsers().remove(user);
+    if (getChannelDataWatch(getChannel(channel)) != null) {
+      getChannelDataWatch(getChannel(channel)).createChannel(getChannel(channel));
     }
+  }
 
-    public void synchronizeUserPostChange(User user, Channel channel)
-    {
-        channel.getAllUsers().add(user);
-        if (getChannelDataWatch(channel) != null) {
-            getChannelDataWatch(channel).userChanged();
-        }
+  public void synchronizeUserPreChange(User user, Channel channel) {
+    channel.getAllUsers().remove(user);
+  }
+
+  public void synchronizeUserPostChange(User user, Channel channel) {
+    channel.getAllUsers().add(user);
+    if (getChannelDataWatch(channel) != null) {
+      getChannelDataWatch(channel).userChanged();
     }
+  }
 
-    public void RemoveUser(User user, Channel channel)
-    {
-        channel.getAllUsers().remove(user);
-        user.getChannelData().remove(channel);
+  public void RemoveUser(User user, Channel channel) {
+    channel.getAllUsers().remove(user);
+    user.getChannelData().remove(channel);
 
-        if (user.getChannelData().size() == 0) {
-            users.remove(user);
-        }
+    if (user.getChannelData().size() == 0) {
+      users.remove(user);
+    }
 
-        if (getChannelDataWatch(channel) != null) {
-            getChannelDataWatch(channel).userRemoved(user);
-        }
+    if (getChannelDataWatch(channel) != null) {
+      getChannelDataWatch(channel).userRemoved(user);
     }
+  }
 }

Modified: rero/src/rero/ircfw/data/ModeTracker.java
===================================================================
--- rero/src/rero/ircfw/data/ModeTracker.java	2006-03-01 16:50:25 UTC (rev 79)
+++ rero/src/rero/ircfw/data/ModeTracker.java	2006-03-18 22:01:02 UTC (rev 80)
@@ -2,143 +2,129 @@
 
 /* the mode parser... code like this always makes my day (not!) */
 
-import rero.ircfw.*;
+import rero.ircfw.Channel;
 import rero.ircfw.interfaces.FrameworkConstants;
 
-import java.util.*;
+import java.util.HashMap;
 
-public class ModeTracker extends DataEventAction implements FrameworkConstants
-{
-    public boolean isEvent(HashMap data)
-    {
-        return ( "MODE".equals(data.get($EVENT$)) || "324".equals(data.get($EVENT$)) || "221".equals(data.get($EVENT$)) );
+public class ModeTracker extends DataEventAction implements FrameworkConstants {
+  public boolean isEvent(HashMap data) {
+    return ("MODE".equals(data.get($EVENT$)) || "324".equals(data.get($EVENT$)) || "221".equals(data.get($EVENT$)));
+  }
+
+  public void process(HashMap data) {
+    String event = (String) data.get($EVENT$);
+    String target = "", modes = "";
+
+    if (event.equals("MODE") || event.equals("221")) {
+      target = (String) data.get($TARGET$);
+      modes = (String) data.get($PARMS$);
+      data.put($PARMS$, modes.trim()); // should fix extra characters being appended to the modes :)
+    } else if (event.equals("324")) {
+      String[] blah = data.get($PARMS$).toString().split("\\s", 2);
+
+      target = blah[0];
+      modes = blah[1];
     }
 
-    public void process(HashMap data)
-    {
-        String event = (String)data.get($EVENT$);
-        String target = "", modes = "";
+    boolean isChannel = (target.charAt(0) == '#' || target.charAt(0) == '&');
+    boolean doSet = false;
 
-        if (event.equals("MODE") || event.equals("221"))
-        {
-           target = (String)data.get($TARGET$);
-           modes   = (String)data.get($PARMS$);
-           data.put($PARMS$, modes.trim()); // should fix extra characters being appended to the modes :)
-        }
-        else if (event.equals("324"))
-        {
-           String[] blah = data.get($PARMS$).toString().split("\\s", 2);
+    String parse[] = modes.split("\\s", 0);
 
-           target = blah[0];
-           modes  = blah[1];
-        }
+    modes = parse[0];
 
-        boolean isChannel = (target.charAt(0) == '#' || target.charAt(0) == '&');
-        boolean doSet = false;
+    int target_index = 1; /* index of current target in parse[] array */
 
-        String parse[] = modes.split("\\s", 0); 
-        
-        modes = parse[0];
+    for (int x = 0; x < modes.length(); x++) {
+      if (modes.charAt(x) == '+') {
+        doSet = true;
+      } else if (modes.charAt(x) == '-') {
+        doSet = false;
+      } else if (isChannel) {
+        Channel ch = dataList.getChannel(target);
 
-        int target_index = 1; /* index of current target in parse[] array */
+        if (dataList.getPrefixInfo().isPrefixMode(modes.charAt(x))) {
+          dataList.synchronizeUserPreChange(dataList.getUser(parse[target_index]), ch);
 
-        for (int x = 0; x < modes.length(); x++)
-        {
-            if (modes.charAt(x) == '+')
-            {
-                doSet = true;
-            }
-            else if (modes.charAt(x) == '-')
-            {
-                doSet = false;
-            }
-            else if (isChannel)
-            {
-                Channel ch = dataList.getChannel(target);
+          int temp = dataList.getUser(parse[target_index]).getModeFor(ch);
 
-                if (dataList.getPrefixInfo().isPrefixMode(modes.charAt(x)))
-                {
-                   dataList.synchronizeUserPreChange(dataList.getUser(parse[target_index]), ch);
+          if (doSet) {
+            dataList.getUser(parse[target_index])
+              .setModeFor(ch, dataList.getPrefixInfo().setMode(temp, modes.charAt(x)));
+          } else {
+            dataList.getUser(parse[target_index])
+              .setModeFor(ch, dataList.getPrefixInfo().unsetMode(temp, modes.charAt(x)));
+          }
 
-                   int temp = dataList.getUser(parse[target_index]).getModeFor(ch);
+          dataList.synchronizeUserPostChange(dataList.getUser(parse[target_index]), ch);
+          target_index++;
+        } else {
+          switch (modes.charAt(x)) {
+            case 'l':
+              if (doSet) {
+                ch.getMode().SetMode('l');
+                ch.setLimit(Integer.parseInt(parse[target_index]));
+                target_index++;
+              } else {
+                ch.getMode().UnsetMode('l');
+                ch.setLimit(-1);
+              }
+              break;
 
-                   if (doSet)
-                   {
-                      dataList.getUser(parse[target_index]).setModeFor(ch, dataList.getPrefixInfo().setMode(temp, modes.charAt(x)));
-                   }
-                   else
-                   {
-                      dataList.getUser(parse[target_index]).setModeFor(ch, dataList.getPrefixInfo().unsetMode(temp, modes.charAt(x)));
-                   }
+            case 'k':
+              if (doSet) {
+                ch.getMode().SetMode('k');
+                ch.setKey(parse[target_index]);
+                target_index++;
+              } else {
+                ch.getMode().UnsetMode('k');
+                target_index++;
+              }
+              break;
 
-                   dataList.synchronizeUserPostChange(dataList.getUser(parse[target_index]), ch);
-                   target_index++;
-                }
-                else
-                {
-                   switch (modes.charAt(x))
-                   {
-                       case 'b':
-                          target_index++;
-                          break;
+            default:
+              // modes from group A (such as b) operate user lists, always have
+              // params and are not handled here
+              if (dataList.isChanGroupMode("A", modes.charAt(x))) {
+                target_index++;
+                break;
+              }
 
-                       case 'l':
-                          if (doSet)
-                          {
-                              ch.getMode().SetMode('l');
-                              ch.setLimit(Integer.parseInt(parse[target_index]));
-                              target_index++;
-                          }
-                          else
-                          { 
-                              ch.getMode().UnsetMode('l');
-                              ch.setLimit(-1);
-                          }
-                          break;
+              // modes from group B (such as k) always have a param,
+              // only k is handled above at the moment, for all the rest just
+              // skip the target and set mode for channel
+              if (dataList.isChanGroupMode("B", modes.charAt(x))) {
+                target_index++;
+              }
 
-                       case 'k':
-                          if (doSet)
-                          {
-                              ch.getMode().SetMode('k');
-                              ch.setKey(parse[target_index]);
-                              target_index++;
-                          }
-                          else
-                          {
-                              ch.getMode().UnsetMode('k');
-                              target_index++;
-                          }
+              // modes from group C (such as l) only have params when set,
+              // so we need to adjust the index when mode is set
+              if (dataList.isChanGroupMode("C", modes.charAt(x)) && doSet) {
+                target_index++;
+              }
 
-                          break;
+              // modes from group D have no params and we don't need to adjust
+              // the target index
 
-                       default:
-                          if (doSet)
-                          {
-                              ch.getMode().SetMode(modes.charAt(x));
-                          }
-                          else
-                          {
-                              ch.getMode().UnsetMode(modes.charAt(x));
-                          }
-                    }
-                }
-            }
-            else
-            {
-                if (!target.equals(dataList.getMyNick()))
-                {
-                    return;
-                }
+              if (doSet) {
+                ch.getMode().SetMode(modes.charAt(x));
+              } else {
+                ch.getMode().UnsetMode(modes.charAt(x));
+              }
+          }
+        }
+      } else {
+        if (!target.equals(dataList.getMyNick())) {
+          return;
+        }
 
-                if (doSet)
-                {
-                    dataList.getMyUserInformation().getMode().SetMode(modes.charAt(x));
-                }
-                else
-                {
-                    dataList.getMyUserInformation().getMode().UnsetMode(modes.charAt(x));
-                }
-            }
+        if (doSet) {
+          dataList.getMyUserInformation().getMode().SetMode(modes.charAt(x));
+        } else {
+          dataList.getMyUserInformation().getMode().UnsetMode(modes.charAt(x));
         }
+      }
     }
+  }
 }

Modified: rero/src/rero/ircfw/data/MyInformationTracker.java
===================================================================
--- rero/src/rero/ircfw/data/MyInformationTracker.java	2006-03-01 16:50:25 UTC (rev 79)
+++ rero/src/rero/ircfw/data/MyInformationTracker.java	2006-03-18 22:01:02 UTC (rev 80)
@@ -3,81 +3,84 @@
 /* keep "my" information in IDL up to date
    my information includes things such as my nickname and all that jazz...  */
 
-import rero.ircfw.*;
 import rero.ircfw.interfaces.FrameworkConstants;
+import rero.util.StringParser;
 
-import rero.util.*;
+import java.util.HashMap;
+import java.util.regex.Pattern;
 
-import java.util.*;
-import java.util.regex.*;
+public class MyInformationTracker extends DataEventAction implements FrameworkConstants {
+  private static String supportPattern = ":.*? 005 .*? (.*?) :.*";
+  private static Pattern isSupport = Pattern.compile(supportPattern);
 
-public class MyInformationTracker extends DataEventAction implements FrameworkConstants
-{
-    private static String  supportPattern = ":.*? 005 .*? (.*?) :.*";
-    private static Pattern isSupport      = Pattern.compile(supportPattern);
+  public boolean isEvent(HashMap data) {
+    String temp = (String) data.get($EVENT$);
 
-    public boolean isEvent(HashMap data)
-    {
-        String temp = (String)data.get($EVENT$);
+    if ("001".equals(temp)) {
+      return true;
+    }
+    if ("305".equals(temp)) {
+      return true;
+    } /* back from being away */
+    if ("306".equals(temp)) {
+      return true;
+    } /* set as away */
+    if ("005".equals(temp)) {
+      return true;
+    }
 
-        if ("001".equals(temp)) { return true; }
-        if ("305".equals(temp)) { return true; } /* back from being away */
-        if ("306".equals(temp)) { return true; } /* set as away */
-        if ("005".equals(temp)) { return true; }
+    return false;
+  }
 
-        return false;
+  public void process(HashMap data) {
+    if ("001".equals(data.get($EVENT$))) {
+      dataList.setMyNick((String) data.get($TARGET$));
     }
 
-    public void process(HashMap data)
-    {
-        if ( "001".equals(data.get($EVENT$)) )
-        {
-            dataList.setMyNick((String)data.get($TARGET$));
-        }
+    if ("305".equals(data.get($EVENT$))) {
+      dataList.getMyUserInformation().setBack();
+    }
 
-        if ("305".equals(data.get($EVENT$)))
-        {
-            dataList.getMyUserInformation().setBack();
-        }
+    if ("306".equals(data.get($EVENT$))) {
+      dataList.getMyUserInformation().setAway();
+    }
 
-        if ("306".equals(data.get($EVENT$)))
-        {
-            dataList.getMyUserInformation().setAway();
-        }
+    if ("005".equals(data.get($EVENT$))) {
+      StringParser parser = new StringParser(data.get($RAW$).toString(), isSupport);
+      if (parser.matches()) {
+        String[] temp = parser.getParsedString(0).split(" ");
+        for (int x = 0; x < temp.length; x++) {
+          String key, value;
 
-        if ("005".equals(data.get($EVENT$)))
-        {
-            StringParser parser = new StringParser(data.get($RAW$).toString(), isSupport);
-            if (parser.matches())
-            {
-               String[] temp = parser.getParsedString(0).split(" ");
-               for (int x = 0; x < temp.length; x++)
-               {
-                  String key, value;
+          if (temp[x].indexOf('=') > -1) {
+            key = temp[x].substring(0, temp[x].indexOf('='));
+            value = temp[x].substring(key.length() + 1, temp[x].length());
 
-                  if (temp[x].indexOf('=') > -1)
-                  {
-                     key    = temp[x].substring(0, temp[x].indexOf('='));
-                     value  = temp[x].substring(key.length() + 1, temp[x].length());
+            dataList.addSupportInfo(key, value);
 
-                     dataList.addSupportInfo(key, value);
+            if (key.equals("PREFIX")) {
+              String chars = value.substring(1, value.indexOf(')'));
+              String modes = value.substring(chars.length() + 2, value.length());
 
-                     if (key.equals("PREFIX"))
-                     {
-                        String chars = value.substring(1, value.indexOf(')'));
-                        String modes = value.substring(chars.length() + 2, value.length());
-
-                        dataList.setPrefixInfo(chars, modes);
-                     }
-                  }
-                  else
-                  {
-                     dataList.addSupportInfo(temp[x], "true");
-                  }
-               }
+              dataList.setPrefixInfo(chars, modes);
+              // split chanmodes to groups
+            } else if (key.equals("CHANMODES")) {
+              String[] groups = value.split(",");
+              // we should have 4 groups
+              if (groups.length == 4) {
+                dataList.setChanGroupMode("A", groups[0]);
+                dataList.setChanGroupMode("B", groups[1]);
+                dataList.setChanGroupMode("C", groups[2]);
+                dataList.setChanGroupMode("D", groups[3]);
+              }
             }
+          } else {
+            dataList.addSupportInfo(temp[x], "true");
+          }
         }
+      }
+    }
 
-    }
+  }
 }
 



